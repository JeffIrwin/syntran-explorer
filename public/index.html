
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title id="title">Syntran explorer</title>
	<link rel="stylesheet" href="styles.css">
	<link rel="shortcut icon" type="image/png" href="/favicon.png?v=2">
</head>

<body>
	<div class="container">
	<!-- <div style="display: table; margin: auto;"> -->
	<div style="max-width: fit-content; margin: auto;">
		<h1 id="heading1">Syntran explorer</h1>
		<h3>Help: <a href="https://github.com/JeffIrwin/syntran">documentation</a> </h3>

		<label for="sample" style="display: inline-block;">Choose a sample: &nbsp;</label>
		<select name="sample" id="sample" onChange=submitSampleSelect()>
			<option value="hello">hello world</option>
			<option value="for">for loops</option>
			<option value="arrays">arrays</option>
			<option value="struct">structs</option>
			<option value="quine">quine</option>
		</select>

		<form id="textForm">
			<label for="sourceText">Source:</label>
			<pre><div class="grow-wrap" id="sourceTextWrap">
			<textarea
				id="sourceText"
				name="text"
				rows="4"
				cols="20"
				autofocus=true
				spellcheck=false
				required>
			</textarea>
			</div></pre>
			<button type="submit">Run (Ctrl+Enter)</button>
		</form>

		<div id="responseContainer">
			<h2>Output:</h2>
			<pre id="responseText"></pre>
		</div>

	</div>
	</div>

<script>

function submitSampleSelect() {
	const sample = document.querySelector('#sample');
	//console.log("id = ", sample.selectedIndex);
	//console.log("vl = ", sample.value);

	// Setting elem.textContent works *until* the user edits the
	// textarea.  After that it can only be changed in javascript via
	// elem.value
	elem = document.getElementById('sourceText');
	switch (sample.value) {
	case "hello":
		elem.value = HELLO_SRC;
		break;
	case "for":
		elem.value = FOR_SRC;
		break;
	case "arrays":
		elem.value = ARRAYS_SRC;
		break;
	case "quine":
		elem.value = QUINE_SRC;
		break;
	case "struct":
		elem.value = STRUCT_SRC;
		break;
	default:
		break;
	}
	document.getElementById("sourceTextWrap").dataset.replicatedValue = elem.value;
}

fetch('/getenv', {
	method: 'POST',
})
.then(response => response.text())
.then(data => {
	//console.log("data = ", data);
	if (data == "staging") {
		document.getElementById("heading1").innerText = "Syntran explorer staging";
		document.getElementById("title").innerText = "Syntran explorer staging";
}
})
.catch(error => {
	console.error('Fetch error:', error);
});

function submitSourceForm(form) {
	event.preventDefault(); // prevent default behavior

	// Set this to indicate possibly long-running jobs
	document.getElementById('responseText').innerText = "Running ...";

	// Create a FormData object from the form
	const formData = new FormData(form);

	//// Debug log
	//for (let [key, value] of formData.entries()) {
	//	console.log(`FormData entry: ${key} = ${value}`);
	//}

	// Send FormData using fetch and update the output with response
	// data
	fetch('/submit', {
		method: 'POST',
		body: formData
	})
	.then(response => response.text())
	.then(data => {
		document.getElementById('responseText').innerHTML = data;
	})
	.catch(error => {
		console.error('Fetch error:', error);
	});
}

// Listen on whole page for hotkey, regardless of where focus is
document.addEventListener('keydown', function(event) {
	if(event.key === "Enter" && (event.metaKey || event.ctrlKey)) {
		submitSourceForm(document.getElementById("textForm"));
	}
});

document.getElementById('textForm').addEventListener('submit', function(event) {
	submitSourceForm(this);
});

const growers = document.querySelectorAll(".grow-wrap");
growers.forEach((grower) => {
	const textarea = grower.querySelector("textarea");
	textarea.addEventListener("input", () => {
		grower.dataset.replicatedValue = textarea.value;
	});
});

const HELLO_SRC =
`println("hello world");
`;

const FOR_SRC =
`for i in [0: 5] {
    println("i = ", i);
}

// Calculate Ï€
let pi = 0.0;
for k in [0: 10] {
    pi += 1 / (16.0 ** k) * (
        4.0 / (8*k + 1) -
        2.0 / (8*k + 4) -
        1.0 / (8*k + 5) -
        1.0 / (8*k + 6)
    );
}
println("pi = ", pi);
`;

const ARRAYS_SRC =
`let matrix = [
    0,  1,  2,  // values
    3,  4,  5,
    6,  7,  8,
    9, 10, 11 ;
    3, 4        // size
];

let x_slice = matrix[:,0];
println("x_slice = ", x_slice);

let y_slice = matrix[1,:];
println("y_slice = ", y_slice);

let mat_slice = matrix[0: 2, 1: 4];
println("mat_slice = ", mat_slice);

matrix[1,:] += 100;
y_slice = matrix[1,:];
println("y_slice = ", y_slice);
`;

const QUINE_SRC =
`fn quine(s: str) {
    let lparen    = char(40);
    let rparen    = char(41);
    let quote     = char(34);
    let semicolon = char(59);
    println(
        s + lparen + quote +
        s + quote + rparen + semicolon
    );
    return;
}
quine("
fn quine(s: str) {
    let lparen    = char(40);
    let rparen    = char(41);
    let quote     = char(34);
    let semicolon = char(59);
    println(
        s + lparen + quote +
        s + quote + rparen + semicolon
    );
    return;
}
quine");
`;

const STRUCT_SRC =
`// declare
struct Point {
	x: [i32; :],
	name: str,
}
// instantiate
let pt0 = Point{x = [20, 10], name = "my-pt0"};
let pt1 = Point{x = [40, 50], name = "my-pt1"};

struct Rect {
	bottom_left: Point,
	upper_right: Point,
	name: str
}
let rect0 = Rect{bottom_left = pt0, upper_right = pt1, name = "my-rect"};

fn area(rect: Rect): i32 {
	let width =
		rect.upper_right.x[0] -
		rect.bottom_left.x[0];
	let height =
		rect.upper_right.x[1] -
		rect.bottom_left.x[1];

	// Taking the absolute value is left as an exercise for the reader
	return width * height;
}
println("area = ", area(rect0));

fn get_unit_rect(): Rect {
	return Rect {
		bottom_left = Point{x = [0, 0], name = "bl"},
		upper_right = Point{x = [1, 1], name = "ur"},
		name = "unit-rect",
	};
}
println("unit area = ", area(get_unit_rect()));
`;

// Initialize source text contents
submitSampleSelect();

</script>
</body>
</html>

